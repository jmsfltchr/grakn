define

############################################################
# Data
############################################################

value sub attribute datatype double;
feature-name sub attribute datatype string;
# double-feature sub attribute datatype double;
# long-feature sub attribute datatype long;
# date-feature sub attribute datatype date;

feature-vector sub relationship,
    relates vector-member,
    plays subject-data;

training-feature-vector sub feature-vector,
    relates vector-member,
    plays training-data;

feature sub entity,
    plays vector-member,
    has value,
    has feature-name;

############################################################
# Forest and tree definition
############################################################

forest sub relationship,
    relates contained-tree,
    relates training-data;

tree sub relationship,
    plays contained-tree,
    relates tree-node,
    relates root as tree-node,
    relates leaf as tree-node;

############################################################
# Tree internals
############################################################

comparison-operator sub attribute datatype string;
decision-boundary sub attribute datatype double;

node sub relationship,
    relates subject-data,
    plays tree-node,
    plays positive-outcome,
    plays negative-outcome,
    relates outcome; # I don't want to include this, but I'm forced to as a result of:
    # (*1) The Role [positive-outcome] which is connected to Relationship Type [decision-node] does not have a super Role Type which is connected to the super Relationship Type [node]

leaf-node sub node,
    relates subject-data,
    relates outcome, # I don't want to include this, but I'm forced to as a result of *1
    plays leaf;
    
decision-node sub node,
    has comparison-operator,
    has decision-boundary,
    has feature-name,
    relates subject-data,
    # We can't do this within the same class yet
    # relates outcome, # whether positive or negative
    # relates positive-outcome as outcome,
    # relates negative-outcome as outcome,
    relates positive-outcome as outcome,
    relates negative-outcome as outcome;

root-node sub decision-node,
    relates subject-data,
    # relates outcome, # whether positive or negative
    relates positive-outcome as outcome, # Once *1 is resolved, 'as outcome' can be removed
    relates negative-outcome as outcome,
    plays root;

############################################################
# Inject training data from forest into each tree
############################################################

inject-at-tree-root sub rule,
when {
    $f(training-data: $fv, contained-tree: $t) isa forest;
    $t(root: $root-node) isa tree;
    $fv isa training-feature-vector;
} then {
    $root-node(subject-data: $fv) isa root-node;
};

############################################################
# Decision-making
############################################################

positive-discrimination sub rule,
when {
    $node(subject-data: $fv, positive-outcome: $destination-node) isa decision-node, 
        has decision-boundary $b, 
        has feature-name $fn;

    $fv(vector-member: $feat) isa feature-vector;
    $feat isa feature, 
        has value $val, 
        has feature-name $fn;
    $val >= $b;
    $destination-node isa node;
} then {
    $destination-node(subject-data: $fv) isa node;
};

negative-discrimination sub rule,
when {
    $node(subject-data: $fv, negative-outcome: $destination-node) isa decision-node, 
        has decision-boundary $b, 
        has feature-name $fn;

    $fv(vector-member: $feat) isa feature-vector;
    $feat isa feature, 
        has value $val, 
        has feature-name $fn;
    $val < $b;
    $destination-node isa node;
} then {
    $destination-node(subject-data: $fv) isa node;
};